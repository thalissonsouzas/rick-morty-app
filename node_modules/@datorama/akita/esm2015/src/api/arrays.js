/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { isObject } from '../internal/utils';
// https://github.com/georapbox/immutable-arrays
/**
 * Adds one or more elements to the end of an array by returning
 * a new array instead of mutating the original one.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = push(originalArray, 'f', 'g');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd', 'e', 'f', 'g']
 * @template T
 * @param {?} array
 * @param {...?} elementN
 * @return {?}
 */
export function push(array, ...elementN) {
    return [...array, ...elementN];
}
/**
 * Deletes an element from an array by its index in the array.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = remove(originalArray, 2);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'd', 'e']
 * @template T
 * @param {?} array
 * @param {?} index
 * @return {?}
 */
export function remove(array, index) {
    return index >= 0 ? [...array.slice(0, index), ...array.slice(index + 1)] : [...array];
}
/**
 * Removes the last element from an array by returning
 * a new array instead of mutating the original one.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = pop(originalArray);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd']
 * @template T
 * @param {?} array
 * @return {?}
 */
export function pop(array) {
    return array.slice(0, -1);
}
/**
 * Adds one or more elements to the beginning of an array.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = unshift(originalArray, 'f', 'g');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['f', 'g', 'a', 'b', 'c', 'd', 'e']
 * @template T
 * @param {?} array
 * @param {...?} elementN
 * @return {?}
 */
export function unshift(array, ...elementN) {
    return [...elementN, ...array];
}
/**
 * Sorts the elements of an array (not in place) and returns a sorted array.
 *
 * \@example
 * const numberArray = [20, 3, 4, 10, -3, 1, 0, 5];
 * const stringArray = ['Blue', 'Humpback', 'Beluga'];
 *
 * const resultArray = sort(numberArray, (a, b) => a - b);
 * // -> numberArray [20, 3, 4, 10, -3, 1, 0, 5]
 * // -> resultArray [-3, 0, 1, 3, 4, 5, 10, 20]
 *
 * const resultArray = sort(numberArray, (a, b) => b - a);
 * // -> numberArray [20, 3, 4, 10, -3, 1, 0, 5]
 * // -> resultArray [20, 10, 5, 4, 3, 1, 0, -3]
 *
 * const resultArray = sort(stringArray);
 * // -> stringArray ['Blue', 'Humpback', 'Beluga']
 * // -> resultArray ['Beluga', 'Blue', 'Humpback']
 *
 * const resultArray = sort(stringArray, (a, b) => a.toLowerCase() < b.toLowerCase());
 * // -> stringArray ['Blue', 'Humpback', 'Beluga']
 * // -> resultArray ['Humpback', 'Blue', 'Beluga']
 * @template T
 * @param {?} array
 * @param {?=} compareFunction
 * @return {?}
 */
export function sort(array, compareFunction) {
    return [...array].sort(compareFunction);
}
/**
 * Reverses an array (not in place).
 * The first array element becomes the last, and the last array element becomes the first.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = reverse(originalArray);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['e', 'd', 'c', 'b', 'a']
 * @template T
 * @param {?} array
 * @return {?}
 */
export function reverse(array) {
    return [...array].reverse();
}
/**
 * Swap items in the array
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = swap(originalArray, 1, 4);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'e', 'c', 'd', 'b']
 * @template T
 * @param {?} array
 * @param {?} firstIndex
 * @param {?} secondIndex
 * @return {?}
 */
export function swap(array, firstIndex, secondIndex) {
    /** @type {?} */
    const results = array.slice();
    /** @type {?} */
    const firstItem = array[firstIndex];
    results[firstIndex] = array[secondIndex];
    results[secondIndex] = firstItem;
    return results;
}
/**
 * Update item in the array
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = update(originalArray, 1, 'newItem');
 * // -> resultArray ['a', 'newItem', 'c', 'd', 'b']
 *
 * const originalArray = [{title: 1}, {title: 2}];
 * const resultArray = update(originalArray, originalArray[0], {title: 3});
 * // -> resultArray  [{title: 3}, {title: 2}];
 * @template T
 * @param {?} array
 * @param {?} indexOrItem
 * @param {?} updated
 * @return {?}
 */
export function update(array, indexOrItem, updated) {
    return array.map((current, idx) => {
        if (typeof indexOrItem === 'number' && idx === indexOrItem) {
            return updated;
        }
        if (isObject(indexOrItem) && ((/** @type {?} */ (indexOrItem))) === current) {
            return Object.assign({}, ((/** @type {?} */ (indexOrItem))), ((/** @type {?} */ (updated))));
        }
        return current;
    });
}
/**
 * Removes existing elements and/or adds new elements to an array.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray []
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 1);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['b', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 3);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['d', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, originalArray.length);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray []
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, -3);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 0, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['lorem', 'ipsum', 'a', 'b', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, originalArray.length, 0, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd', 'e', 'lorem', 'ipsum']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 2, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['lorem', 'ipsum', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, originalArray.length - 2, 2, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'lorem', 'ipsum']
 * @template T
 * @param {?} array
 * @param {?=} start
 * @param {?=} deleteCount
 * @param {...?} elementN
 * @return {?}
 */
export function splice(array, start = array.length, deleteCount = array.length - start, ...elementN) {
    return [...array.slice(0, start), ...elementN, ...array.slice(start + (deleteCount < 0 ? 0 : deleteCount))];
}
/**
 * @template T
 * @param {?} arr
 * @param {?} item
 * @return {?}
 */
export function toggle(arr, item) {
    return arr.indexOf(item) > -1 ? arr.filter(current => item !== current) : push(arr, item);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXlzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGRhdG9yYW1hL2FraXRhLyIsInNvdXJjZXMiOlsic3JjL2FwaS9hcnJheXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQWM3QyxNQUFNLFVBQVUsSUFBSSxDQUFJLEtBQVUsRUFBRSxHQUFHLFFBQWE7SUFDbEQsT0FBTyxDQUFDLEdBQUcsS0FBSyxFQUFFLEdBQUcsUUFBUSxDQUFDLENBQUM7QUFDakMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUFXRCxNQUFNLFVBQVUsTUFBTSxDQUFJLEtBQVUsRUFBRSxLQUFhO0lBQ2pELE9BQU8sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ3pGLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FBWUQsTUFBTSxVQUFVLEdBQUcsQ0FBSSxLQUFVO0lBQy9CLE9BQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QixDQUFDOzs7Ozs7Ozs7Ozs7OztBQVdELE1BQU0sVUFBVSxPQUFPLENBQUksS0FBVSxFQUFFLEdBQUcsUUFBYTtJQUNyRCxPQUFPLENBQUMsR0FBRyxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQztBQUNqQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJELE1BQU0sVUFBVSxJQUFJLENBQUksS0FBVSxFQUFFLGVBQXdDO0lBQzFFLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUMxQyxDQUFDOzs7Ozs7Ozs7Ozs7OztBQVlELE1BQU0sVUFBVSxPQUFPLENBQUksS0FBVTtJQUNuQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM5QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFXRCxNQUFNLFVBQVUsSUFBSSxDQUFJLEtBQVUsRUFBRSxVQUFrQixFQUFFLFdBQW1COztVQUNuRSxPQUFPLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRTs7VUFDdkIsU0FBUyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7SUFDbkMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN6QyxPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsU0FBUyxDQUFDO0lBRWpDLE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWNELE1BQU0sVUFBVSxNQUFNLENBQUksS0FBVSxFQUFFLFdBQTRCLEVBQUUsT0FBVTtJQUM1RSxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDaEMsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLElBQUksR0FBRyxLQUFLLFdBQVcsRUFBRTtZQUMxRCxPQUFPLE9BQU8sQ0FBQztTQUNoQjtRQUVELElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsbUJBQUEsV0FBVyxFQUFPLENBQUMsS0FBSyxPQUFPLEVBQUU7WUFDN0QseUJBQ0ssQ0FBQyxtQkFBQSxXQUFXLEVBQVUsQ0FBQyxFQUN2QixDQUFDLG1CQUFBLE9BQU8sRUFBTyxDQUFDLEVBQ25CO1NBQ0g7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURELE1BQU0sVUFBVSxNQUFNLENBQUksS0FBVSxFQUFFLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLFdBQVcsR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssRUFBRSxHQUFHLFFBQWE7SUFDOUcsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsR0FBRyxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlHLENBQUM7Ozs7Ozs7QUFFRCxNQUFNLFVBQVUsTUFBTSxDQUFJLEdBQVEsRUFBRSxJQUFPO0lBQ3pDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM1RixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuLi9pbnRlcm5hbC91dGlscyc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nZW9yYXBib3gvaW1tdXRhYmxlLWFycmF5c1xuXG4vKipcbiAqIEFkZHMgb25lIG9yIG1vcmUgZWxlbWVudHMgdG8gdGhlIGVuZCBvZiBhbiBhcnJheSBieSByZXR1cm5pbmdcbiAqIGEgbmV3IGFycmF5IGluc3RlYWQgb2YgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIG9uZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHB1c2gob3JpZ2luYWxBcnJheSwgJ2YnLCAnZycpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaDxUPihhcnJheTogVFtdLCAuLi5lbGVtZW50TjogVFtdKTogVFtdIHtcbiAgcmV0dXJuIFsuLi5hcnJheSwgLi4uZWxlbWVudE5dO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgYW4gZWxlbWVudCBmcm9tIGFuIGFycmF5IGJ5IGl0cyBpbmRleCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSByZW1vdmUob3JpZ2luYWxBcnJheSwgMik7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYScsICdiJywgJ2QnLCAnZSddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmU8VD4oYXJyYXk6IFRbXSwgaW5kZXg6IG51bWJlcik6IFRbXSB7XG4gIHJldHVybiBpbmRleCA+PSAwID8gWy4uLmFycmF5LnNsaWNlKDAsIGluZGV4KSwgLi4uYXJyYXkuc2xpY2UoaW5kZXggKyAxKV0gOiBbLi4uYXJyYXldO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGxhc3QgZWxlbWVudCBmcm9tIGFuIGFycmF5IGJ5IHJldHVybmluZ1xuICogYSBuZXcgYXJyYXkgaW5zdGVhZCBvZiBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gcG9wKG9yaWdpbmFsQXJyYXkpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wPFQ+KGFycmF5OiBUW10pOiBUW10ge1xuICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgLTEpO1xufVxuXG4vKipcbiAqIEFkZHMgb25lIG9yIG1vcmUgZWxlbWVudHMgdG8gdGhlIGJlZ2lubmluZyBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHVuc2hpZnQob3JpZ2luYWxBcnJheSwgJ2YnLCAnZycpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2YnLCAnZycsICdhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5zaGlmdDxUPihhcnJheTogVFtdLCAuLi5lbGVtZW50TjogVFtdKTogVFtdIHtcbiAgcmV0dXJuIFsuLi5lbGVtZW50TiwgLi4uYXJyYXldO1xufVxuXG4vKipcbiAqIFNvcnRzIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSAobm90IGluIHBsYWNlKSBhbmQgcmV0dXJucyBhIHNvcnRlZCBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbnVtYmVyQXJyYXkgPSBbMjAsIDMsIDQsIDEwLCAtMywgMSwgMCwgNV07XG4gKiBjb25zdCBzdHJpbmdBcnJheSA9IFsnQmx1ZScsICdIdW1wYmFjaycsICdCZWx1Z2EnXTtcbiAqXG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNvcnQobnVtYmVyQXJyYXksIChhLCBiKSA9PiBhIC0gYik7XG4gKiAvLyAtPiBudW1iZXJBcnJheSBbMjAsIDMsIDQsIDEwLCAtMywgMSwgMCwgNV1cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFstMywgMCwgMSwgMywgNCwgNSwgMTAsIDIwXVxuICpcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc29ydChudW1iZXJBcnJheSwgKGEsIGIpID0+IGIgLSBhKTtcbiAqIC8vIC0+IG51bWJlckFycmF5IFsyMCwgMywgNCwgMTAsIC0zLCAxLCAwLCA1XVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWzIwLCAxMCwgNSwgNCwgMywgMSwgMCwgLTNdXG4gKlxuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzb3J0KHN0cmluZ0FycmF5KTtcbiAqIC8vIC0+IHN0cmluZ0FycmF5IFsnQmx1ZScsICdIdW1wYmFjaycsICdCZWx1Z2EnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydCZWx1Z2EnLCAnQmx1ZScsICdIdW1wYmFjayddXG4gKlxuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzb3J0KHN0cmluZ0FycmF5LCAoYSwgYikgPT4gYS50b0xvd2VyQ2FzZSgpIDwgYi50b0xvd2VyQ2FzZSgpKTtcbiAqIC8vIC0+IHN0cmluZ0FycmF5IFsnQmx1ZScsICdIdW1wYmFjaycsICdCZWx1Z2EnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydIdW1wYmFjaycsICdCbHVlJywgJ0JlbHVnYSddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0PFQ+KGFycmF5OiBUW10sIGNvbXBhcmVGdW5jdGlvbj86IChhOiBULCBiOiBUKSA9PiBudW1iZXIpOiBUW10ge1xuICByZXR1cm4gWy4uLmFycmF5XS5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG59XG5cbi8qKlxuICogUmV2ZXJzZXMgYW4gYXJyYXkgKG5vdCBpbiBwbGFjZSkuXG4gKiBUaGUgZmlyc3QgYXJyYXkgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCBhbmQgdGhlIGxhc3QgYXJyYXkgZWxlbWVudCBiZWNvbWVzIHRoZSBmaXJzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHJldmVyc2Uob3JpZ2luYWxBcnJheSk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnZScsICdkJywgJ2MnLCAnYicsICdhJ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2U8VD4oYXJyYXk6IFRbXSk6IFRbXSB7XG4gIHJldHVybiBbLi4uYXJyYXldLnJldmVyc2UoKTtcbn1cblxuLyoqXG4gKiBTd2FwIGl0ZW1zIGluIHRoZSBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc3dhcChvcmlnaW5hbEFycmF5LCAxLCA0KTtcbiAqIC8vIC0+IG9yaWdpbmFsQXJyYXkgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydhJywgJ2UnLCAnYycsICdkJywgJ2InXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3dhcDxUPihhcnJheTogVFtdLCBmaXJzdEluZGV4OiBudW1iZXIsIHNlY29uZEluZGV4OiBudW1iZXIpOiBUW10ge1xuICBjb25zdCByZXN1bHRzID0gYXJyYXkuc2xpY2UoKTtcbiAgY29uc3QgZmlyc3RJdGVtID0gYXJyYXlbZmlyc3RJbmRleF07XG4gIHJlc3VsdHNbZmlyc3RJbmRleF0gPSBhcnJheVtzZWNvbmRJbmRleF07XG4gIHJlc3VsdHNbc2Vjb25kSW5kZXhdID0gZmlyc3RJdGVtO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBpdGVtIGluIHRoZSBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gdXBkYXRlKG9yaWdpbmFsQXJyYXksIDEsICduZXdJdGVtJyk7XG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2EnLCAnbmV3SXRlbScsICdjJywgJ2QnLCAnYiddXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFt7dGl0bGU6IDF9LCB7dGl0bGU6IDJ9XTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gdXBkYXRlKG9yaWdpbmFsQXJyYXksIG9yaWdpbmFsQXJyYXlbMF0sIHt0aXRsZTogM30pO1xuICogLy8gLT4gcmVzdWx0QXJyYXkgIFt7dGl0bGU6IDN9LCB7dGl0bGU6IDJ9XTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZTxUPihhcnJheTogVFtdLCBpbmRleE9ySXRlbTogbnVtYmVyIHwgb2JqZWN0LCB1cGRhdGVkOiBUKTogVFtdIHtcbiAgcmV0dXJuIGFycmF5Lm1hcCgoY3VycmVudCwgaWR4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbmRleE9ySXRlbSA9PT0gJ251bWJlcicgJiYgaWR4ID09PSBpbmRleE9ySXRlbSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KGluZGV4T3JJdGVtKSAmJiAoaW5kZXhPckl0ZW0gYXMgYW55KSA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKGluZGV4T3JJdGVtIGFzIG9iamVjdCksXG4gICAgICAgIC4uLih1cGRhdGVkIGFzIGFueSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZXhpc3RpbmcgZWxlbWVudHMgYW5kL29yIGFkZHMgbmV3IGVsZW1lbnRzIHRvIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc3BsaWNlKG9yaWdpbmFsQXJyYXksIDApO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbXVxuICpcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzcGxpY2Uob3JpZ2luYWxBcnJheSwgMCwgMSk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYicsICdjJywgJ2QnLCAnZSddXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCAwLCAzKTtcbiAqIC8vIC0+IG9yaWdpbmFsQXJyYXkgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydkJywgJ2UnXVxuICpcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzcGxpY2Uob3JpZ2luYWxBcnJheSwgMCwgb3JpZ2luYWxBcnJheS5sZW5ndGgpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbXVxuICpcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzcGxpY2Uob3JpZ2luYWxBcnJheSwgMCwgLTMpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCAwLCAwLCAnbG9yZW0nLCAnaXBzdW0nKTtcbiAqIC8vIC0+IG9yaWdpbmFsQXJyYXkgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydsb3JlbScsICdpcHN1bScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICpcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzcGxpY2Uob3JpZ2luYWxBcnJheSwgb3JpZ2luYWxBcnJheS5sZW5ndGgsIDAsICdsb3JlbScsICdpcHN1bScpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdsb3JlbScsICdpcHN1bSddXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCAwLCAyLCAnbG9yZW0nLCAnaXBzdW0nKTtcbiAqIC8vIC0+IG9yaWdpbmFsQXJyYXkgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydsb3JlbScsICdpcHN1bScsICdjJywgJ2QnLCAnZSddXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCBvcmlnaW5hbEFycmF5Lmxlbmd0aCAtIDIsIDIsICdsb3JlbScsICdpcHN1bScpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2EnLCAnYicsICdjJywgJ2xvcmVtJywgJ2lwc3VtJ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGljZTxUPihhcnJheTogVFtdLCBzdGFydCA9IGFycmF5Lmxlbmd0aCwgZGVsZXRlQ291bnQgPSBhcnJheS5sZW5ndGggLSBzdGFydCwgLi4uZWxlbWVudE46IFRbXSk6IFRbXSB7XG4gIHJldHVybiBbLi4uYXJyYXkuc2xpY2UoMCwgc3RhcnQpLCAuLi5lbGVtZW50TiwgLi4uYXJyYXkuc2xpY2Uoc3RhcnQgKyAoZGVsZXRlQ291bnQgPCAwID8gMCA6IGRlbGV0ZUNvdW50KSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlPFQ+KGFycjogVFtdLCBpdGVtOiBUKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZihpdGVtKSA+IC0xID8gYXJyLmZpbHRlcihjdXJyZW50ID0+IGl0ZW0gIT09IGN1cnJlbnQpIDogcHVzaChhcnIsIGl0ZW0pO1xufVxuIl19