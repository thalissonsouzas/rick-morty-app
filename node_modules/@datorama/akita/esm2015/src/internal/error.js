/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { entityExists, isObject, toBoolean } from './utils';
export class AkitaError extends Error {
    /**
     * @param {?} message
     */
    constructor(message) {
        super(message);
    }
}
export class AkitaImmutabilityError extends AkitaError {
    /**
     * @param {?} storeName
     */
    constructor(storeName) {
        super(`The new state should be immutable. Make sure to return a new immutable state. \n store: \n ${storeName}`);
    }
}
export class AkitaEntityNotExistsError extends AkitaError {
    /**
     * @param {?} id
     */
    constructor(id) {
        super(`Entity ${id} does not exists`);
    }
}
export class AkitaNoActiveError extends AkitaError {
    constructor() {
        super(`Active is null/undefined`);
    }
}
export class AkitaInvalidEntityState extends AkitaError {
    constructor() {
        super(`Entity state is invalid`);
    }
}
export class AkitaUpdateIdKeyError extends AkitaError {
    constructor() {
        super(`Updating entity id is not permitted when updating many entities`);
    }
}
/**
 * @param {?} id
 * @param {?} entities
 * @return {?}
 */
export function assertEntityExists(id, entities) {
    if (!entityExists(id, entities)) {
        throw new AkitaEntityNotExistsError(id);
    }
}
/**
 * @param {?} store
 * @return {?}
 */
export function assertActive(store) {
    if (!toBoolean(store.active)) {
        throw new AkitaNoActiveError();
    }
}
/**
 * @param {?} state
 * @return {?}
 */
export function assertEntityState(state) {
    /** @type {?} */
    const assertEntities = isObject(state);
    if (!assertEntities) {
        throw new AkitaInvalidEntityState();
    }
}
/**
 * @param {?} name
 * @param {?} className
 * @return {?}
 */
export function assertDecorator(name, className) {
    if (!name) {
        console.error(`@StoreConfig({ name }) is missing in ${className}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZGF0b3JhbWEvYWtpdGEvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvZXJyb3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUc1RCxNQUFNLE9BQU8sVUFBVyxTQUFRLEtBQUs7Ozs7SUFDbkMsWUFBWSxPQUFlO1FBQ3pCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqQixDQUFDO0NBQ0Y7QUFFRCxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsVUFBVTs7OztJQUNwRCxZQUFZLFNBQVM7UUFDbkIsS0FBSyxDQUFDLDhGQUE4RixTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ25ILENBQUM7Q0FDRjtBQUVELE1BQU0sT0FBTyx5QkFBMEIsU0FBUSxVQUFVOzs7O0lBQ3ZELFlBQVksRUFBRTtRQUNaLEtBQUssQ0FBQyxVQUFVLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUN4QyxDQUFDO0NBQ0Y7QUFFRCxNQUFNLE9BQU8sa0JBQW1CLFNBQVEsVUFBVTtJQUNoRDtRQUNFLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7Q0FDRjtBQUVELE1BQU0sT0FBTyx1QkFBd0IsU0FBUSxVQUFVO0lBQ3JEO1FBQ0UsS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDbkMsQ0FBQztDQUNGO0FBRUQsTUFBTSxPQUFPLHFCQUFzQixTQUFRLFVBQVU7SUFDbkQ7UUFDRSxLQUFLLENBQUMsaUVBQWlFLENBQUMsQ0FBQztJQUMzRSxDQUFDO0NBQ0Y7Ozs7OztBQUVELE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxFQUFNLEVBQUUsUUFBUTtJQUNqRCxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsRUFBRTtRQUMvQixNQUFNLElBQUkseUJBQXlCLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDekM7QUFDSCxDQUFDOzs7OztBQUVELE1BQU0sVUFBVSxZQUFZLENBQUMsS0FBSztJQUNoQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUM1QixNQUFNLElBQUksa0JBQWtCLEVBQUUsQ0FBQztLQUNoQztBQUNILENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLEtBQXVCOztVQUNqRCxjQUFjLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQztJQUV0QyxJQUFJLENBQUMsY0FBYyxFQUFFO1FBQ25CLE1BQU0sSUFBSSx1QkFBdUIsRUFBRSxDQUFDO0tBQ3JDO0FBQ0gsQ0FBQzs7Ozs7O0FBRUQsTUFBTSxVQUFVLGVBQWUsQ0FBQyxJQUFZLEVBQUUsU0FBaUI7SUFDN0QsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE9BQU8sQ0FBQyxLQUFLLENBQUMsd0NBQXdDLFNBQVMsRUFBRSxDQUFDLENBQUM7S0FDcEU7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW50aXR5RXhpc3RzLCBpc09iamVjdCwgdG9Cb29sZWFuIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBFbnRpdHlTdGF0ZSwgSUQgfSBmcm9tICcuLi9hcGkvdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgQWtpdGFFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFraXRhSW1tdXRhYmlsaXR5RXJyb3IgZXh0ZW5kcyBBa2l0YUVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RvcmVOYW1lKSB7XG4gICAgc3VwZXIoYFRoZSBuZXcgc3RhdGUgc2hvdWxkIGJlIGltbXV0YWJsZS4gTWFrZSBzdXJlIHRvIHJldHVybiBhIG5ldyBpbW11dGFibGUgc3RhdGUuIFxcbiBzdG9yZTogXFxuICR7c3RvcmVOYW1lfWApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBa2l0YUVudGl0eU5vdEV4aXN0c0Vycm9yIGV4dGVuZHMgQWtpdGFFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgc3VwZXIoYEVudGl0eSAke2lkfSBkb2VzIG5vdCBleGlzdHNgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWtpdGFOb0FjdGl2ZUVycm9yIGV4dGVuZHMgQWtpdGFFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBBY3RpdmUgaXMgbnVsbC91bmRlZmluZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWtpdGFJbnZhbGlkRW50aXR5U3RhdGUgZXh0ZW5kcyBBa2l0YUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYEVudGl0eSBzdGF0ZSBpcyBpbnZhbGlkYCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFraXRhVXBkYXRlSWRLZXlFcnJvciBleHRlbmRzIEFraXRhRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgVXBkYXRpbmcgZW50aXR5IGlkIGlzIG5vdCBwZXJtaXR0ZWQgd2hlbiB1cGRhdGluZyBtYW55IGVudGl0aWVzYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEVudGl0eUV4aXN0cyhpZDogSUQsIGVudGl0aWVzKSB7XG4gIGlmICghZW50aXR5RXhpc3RzKGlkLCBlbnRpdGllcykpIHtcbiAgICB0aHJvdyBuZXcgQWtpdGFFbnRpdHlOb3RFeGlzdHNFcnJvcihpZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEFjdGl2ZShzdG9yZSkge1xuICBpZiAoIXRvQm9vbGVhbihzdG9yZS5hY3RpdmUpKSB7XG4gICAgdGhyb3cgbmV3IEFraXRhTm9BY3RpdmVFcnJvcigpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbnRpdHlTdGF0ZShzdGF0ZTogRW50aXR5U3RhdGU8YW55Pikge1xuICBjb25zdCBhc3NlcnRFbnRpdGllcyA9IGlzT2JqZWN0KHN0YXRlKTtcblxuICBpZiAoIWFzc2VydEVudGl0aWVzKSB7XG4gICAgdGhyb3cgbmV3IEFraXRhSW52YWxpZEVudGl0eVN0YXRlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydERlY29yYXRvcihuYW1lOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gIGlmICghbmFtZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYEBTdG9yZUNvbmZpZyh7IG5hbWUgfSkgaXMgbWlzc2luZyBpbiAke2NsYXNzTmFtZX1gKTtcbiAgfVxufVxuIl19