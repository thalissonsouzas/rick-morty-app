/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { AkitaUpdateIdKeyError, assertEntityExists, assertEntityState } from './error';
import { entityExists, isFunction, isPlainObject, resetActive } from './utils';
export class CRUD {
    /**
     * @template S, E
     * @param {?} state
     * @param {?} entities
     * @param {?} entityClass
     * @param {?} idKey
     * @return {?}
     */
    _set(state, entities, entityClass, idKey) {
        /** @type {?} */
        let ids;
        /** @type {?} */
        let normalized;
        if (((/** @type {?} */ (entities))).ids && ((/** @type {?} */ (entities))).entities) {
            ids = ((/** @type {?} */ (entities))).ids;
            normalized = ((/** @type {?} */ (entities))).entities;
        }
        else {
            /** @type {?} */
            const isArray = Array.isArray(entities);
            normalized = entities;
            if (isArray) {
                normalized = (/** @type {?} */ (this.keyBy((/** @type {?} */ (entities)), entityClass, idKey)));
            }
            else {
                assertEntityState(entities);
            }
            ids = isArray ? ((/** @type {?} */ (entities))).map(entity => entity[idKey]) : Object.keys((/** @type {?} */ (normalized))).map(id => entities[id][idKey]);
        }
        /** @type {?} */
        const newState = Object.assign({}, ((/** @type {?} */ (state))), { entities: normalized, ids, loading: false });
        if (resetActive(newState)) {
            newState.active = null;
        }
        return newState;
    }
    /**
     * @template T
     * @param {?} state
     * @param {?} id
     * @param {?} entity
     * @return {?}
     */
    _replaceEntity(state, id, entity) {
        return Object.assign({}, ((/** @type {?} */ (state))), { entities: Object.assign({}, state.entities, { [id]: entity }) });
    }
    /**
     * @template S, E
     * @param {?} state
     * @param {?} entities
     * @param {?} idKey
     * @param {?=} options
     * @return {?}
     */
    _add(state, entities, idKey, options = {}) {
        /** @type {?} */
        let addedEntities = {};
        /** @type {?} */
        let addedIds = [];
        for (let i = 0; i < entities.length; i++) {
            /** @type {?} */
            const entity = entities[i];
            /** @type {?} */
            const entityId = entity[idKey];
            if (!entityExists(entityId, state.entities)) {
                addedEntities[entityId] = entity;
                if (options.prepend)
                    addedIds.unshift(entityId);
                else
                    addedIds.push(entityId);
            }
        }
        return Object.assign({}, ((/** @type {?} */ (state))), { entities: Object.assign({}, state.entities, addedEntities), ids: options.prepend ? [...addedIds, ...state.ids] : [...state.ids, ...addedIds] });
    }
    /**
     * @template T
     * @param {?} state
     * @param {?} ids
     * @param {?} newStateOrFn
     * @param {?} idKey
     * @return {?}
     */
    _update(state, ids, newStateOrFn, idKey) {
        /** @type {?} */
        const updatedEntities = {};
        /** @type {?} */
        let isUpdatingIdKey = false;
        /** @type {?} */
        let idToUpdate;
        for (let i = 0; i < ids.length; i++) {
            /** @type {?} */
            const id = ids[i];
            idToUpdate = id;
            assertEntityExists(id, state.entities);
            /** @type {?} */
            const oldEntity = state.entities[id];
            /** @type {?} */
            const newState = isFunction(newStateOrFn) ? newStateOrFn(oldEntity) : newStateOrFn;
            if (newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey]) {
                if (ids.length > 1) {
                    throw new AkitaUpdateIdKeyError();
                }
                isUpdatingIdKey = true;
                idToUpdate = newState[idKey];
            }
            /** @type {?} */
            let newEntity;
            /** @type {?} */
            const merged = Object.assign({}, oldEntity, newState);
            if (isPlainObject(oldEntity)) {
                newEntity = merged;
            }
            else {
                /**
                 * In case that new state is class of it's own, there's
                 * a possibility that it will be different than the old
                 * class.
                 * For example, Old state is an instance of animal class
                 * and new state is instance of person class.
                 * To avoid run over new person class with the old animal
                 * class we check if the new state is a class of it's own.
                 * If so, use it. Otherwise, use the old state class
                 */
                if (isPlainObject(newState)) {
                    newEntity = new oldEntity.constructor(merged);
                }
                else {
                    newEntity = new ((/** @type {?} */ (newState))).constructor(merged);
                }
            }
            updatedEntities[idToUpdate] = newEntity;
        }
        /** @type {?} */
        let updatedIds = state.ids;
        /** @type {?} */
        let stateEntities = state.entities;
        if (isUpdatingIdKey) {
            const [id] = ids;
            const _a = state.entities, _b = id, deletedEntity = _a[_b], rest = tslib_1.__rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
            stateEntities = rest;
            updatedIds = state.ids.map(current => (current === id ? idToUpdate : current));
        }
        return Object.assign({}, ((/** @type {?} */ (state))), { entities: Object.assign({}, stateEntities, updatedEntities), ids: updatedIds });
    }
    /**
     * @template T
     * @param {?} state
     * @param {?} ids
     * @return {?}
     */
    _remove(state, ids) {
        if (!ids)
            return this._removeAll(state);
        /** @type {?} */
        const removed = ids.reduce((acc, id) => {
            const _a = id, entity = acc[_a], rest = tslib_1.__rest(acc, [typeof _a === "symbol" ? _a : _a + ""]);
            return rest;
        }, state.entities);
        /** @type {?} */
        const newState = Object.assign({}, ((/** @type {?} */ (state))), { entities: removed, ids: state.ids.filter(current => ids.indexOf(current) === -1) });
        if (resetActive(newState)) {
            newState.active = null;
        }
        return newState;
    }
    /**
     * @template T
     * @param {?} state
     * @return {?}
     */
    _removeAll(state) {
        /** @type {?} */
        const newState = Object.assign({}, ((/** @type {?} */ (state))), { entities: {}, ids: [], active: null });
        return newState;
    }
    /**
     * @param {?} entities
     * @param {?=} entityClass
     * @param {?=} id
     * @return {?}
     */
    keyBy(entities, entityClass, id = 'id') {
        /** @type {?} */
        const acc = {};
        for (let i = 0, len = entities.length; i < len; i++) {
            /** @type {?} */
            const entity = entities[i];
            acc[entity[id]] = entityClass ? new entityClass(entity) : entity;
        }
        return acc;
    }
}
/** @type {?} */
export const _crud = new CRUD();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J1ZC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BkYXRvcmFtYS9ha2l0YS8iLCJzb3VyY2VzIjpbInNyYy9pbnRlcm5hbC9jcnVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3ZGLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFL0UsTUFBTSxPQUFPLElBQUk7Ozs7Ozs7OztJQUNmLElBQUksQ0FBTyxLQUFRLEVBQUUsUUFBd0MsRUFBRSxXQUFtQyxFQUFFLEtBQUs7O1lBQ25HLEdBQUc7O1lBQUUsVUFBVTtRQUVuQixJQUFJLENBQUMsbUJBQUEsUUFBUSxFQUFlLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxtQkFBQSxRQUFRLEVBQWUsQ0FBQyxDQUFDLFFBQVEsRUFBRTtZQUN2RSxHQUFHLEdBQUcsQ0FBQyxtQkFBQSxRQUFRLEVBQWUsQ0FBQyxDQUFDLEdBQUcsQ0FBQztZQUNwQyxVQUFVLEdBQUcsQ0FBQyxtQkFBQSxRQUFRLEVBQWUsQ0FBQyxDQUFDLFFBQVEsQ0FBQztTQUNqRDthQUFNOztrQkFDQyxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUM7WUFDdkMsVUFBVSxHQUFHLFFBQVEsQ0FBQztZQUV0QixJQUFJLE9BQU8sRUFBRTtnQkFDWCxVQUFVLEdBQUcsbUJBQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxtQkFBQSxRQUFRLEVBQU8sRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLEVBQU8sQ0FBQzthQUNyRTtpQkFBTTtnQkFDTCxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM3QjtZQUVELEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQUEsUUFBUSxFQUFPLENBQUMsQ0FBQyxHQUFHLENB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LEdBQUcsSUFBSTs7Y0FDNUQsR0FBRyxHQUFHLEVBQUU7UUFFZCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFOztrQkFDN0MsTUFBTSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDMUIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztTQUNsRTtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztDQUNGOztBQUVELE1BQU0sT0FBTyxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnRpdGllcywgRW50aXR5U3RhdGUsIEhhc2hNYXAsIElELCBOZXdhYmxlLCBBZGRPcHRpb25zIH0gZnJvbSAnLi4vYXBpL3R5cGVzJztcbmltcG9ydCB7IEFraXRhVXBkYXRlSWRLZXlFcnJvciwgYXNzZXJ0RW50aXR5RXhpc3RzLCBhc3NlcnRFbnRpdHlTdGF0ZSB9IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgZW50aXR5RXhpc3RzLCBpc0Z1bmN0aW9uLCBpc1BsYWluT2JqZWN0LCByZXNldEFjdGl2ZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgQ1JVRCB7XG4gIF9zZXQ8UywgRT4oc3RhdGU6IFMsIGVudGl0aWVzOiBFW10gfCBIYXNoTWFwPEU+IHwgRW50aXRpZXM8RT4sIGVudGl0eUNsYXNzOiBOZXdhYmxlPEU+IHwgdW5kZWZpbmVkLCBpZEtleSk6IFMge1xuICAgIGxldCBpZHMsIG5vcm1hbGl6ZWQ7XG5cbiAgICBpZiAoKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5pZHMgJiYgKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5lbnRpdGllcykge1xuICAgICAgaWRzID0gKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5pZHM7XG4gICAgICBub3JtYWxpemVkID0gKGVudGl0aWVzIGFzIEVudGl0aWVzPEU+KS5lbnRpdGllcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoZW50aXRpZXMpO1xuICAgICAgbm9ybWFsaXplZCA9IGVudGl0aWVzO1xuXG4gICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICBub3JtYWxpemVkID0gdGhpcy5rZXlCeShlbnRpdGllcyBhcyBFW10sIGVudGl0eUNsYXNzLCBpZEtleSkgYXMgRVtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0RW50aXR5U3RhdGUoZW50aXRpZXMpO1xuICAgICAgfVxuXG4gICAgICBpZHMgPSBpc0FycmF5ID8gKGVudGl0aWVzIGFzIEVbXSkubWFwKGVudGl0eSA9PiBlbnRpdHlbaWRLZXldKSA6IE9iamVjdC5rZXlzKG5vcm1hbGl6ZWQgYXMgSGFzaE1hcDxFPikubWFwKGlkID0+IGVudGl0aWVzW2lkXVtpZEtleV0pO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgLi4uKHN0YXRlIGFzIGFueSksXG4gICAgICBlbnRpdGllczogbm9ybWFsaXplZCxcbiAgICAgIGlkcyxcbiAgICAgIGxvYWRpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChyZXNldEFjdGl2ZShuZXdTdGF0ZSkpIHtcbiAgICAgIG5ld1N0YXRlLmFjdGl2ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG5cbiAgX3JlcGxhY2VFbnRpdHk8VCBleHRlbmRzIEVudGl0eVN0YXRlPihzdGF0ZTogVCwgaWQ6IElELCBlbnRpdHkpOiBUIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uKHN0YXRlIGFzIGFueSksXG4gICAgICBlbnRpdGllczoge1xuICAgICAgICAuLi5zdGF0ZS5lbnRpdGllcyxcbiAgICAgICAgW2lkXTogZW50aXR5XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9hZGQ8UyBleHRlbmRzIEVudGl0eVN0YXRlLCBFPihzdGF0ZTogUywgZW50aXRpZXM6IEVbXSwgaWRLZXksIG9wdGlvbnM6IEFkZE9wdGlvbnMgPSB7fSk6IFMge1xuICAgIGxldCBhZGRlZEVudGl0aWVzID0ge307XG4gICAgbGV0IGFkZGVkSWRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudGl0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBlbnRpdGllc1tpXTtcbiAgICAgIGNvbnN0IGVudGl0eUlkID0gZW50aXR5W2lkS2V5XTtcblxuICAgICAgaWYgKCFlbnRpdHlFeGlzdHMoZW50aXR5SWQsIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgICBhZGRlZEVudGl0aWVzW2VudGl0eUlkXSA9IGVudGl0eTtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlcGVuZCkgYWRkZWRJZHMudW5zaGlmdChlbnRpdHlJZCk7XG4gICAgICAgIGVsc2UgYWRkZWRJZHMucHVzaChlbnRpdHlJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLihzdGF0ZSBhcyBhbnkpLFxuICAgICAgZW50aXRpZXM6IHtcbiAgICAgICAgLi4uc3RhdGUuZW50aXRpZXMsXG4gICAgICAgIC4uLmFkZGVkRW50aXRpZXNcbiAgICAgIH0sXG4gICAgICBpZHM6IG9wdGlvbnMucHJlcGVuZCA/IFsuLi5hZGRlZElkcywgLi4uc3RhdGUuaWRzXSA6IFsuLi5zdGF0ZS5pZHMsIC4uLmFkZGVkSWRzXVxuICAgIH07XG4gIH1cblxuICBfdXBkYXRlPFQgZXh0ZW5kcyBFbnRpdHlTdGF0ZT4oc3RhdGU6IFQsIGlkczogSURbXSwgbmV3U3RhdGVPckZuOiBvYmplY3QgfCAoKGU6IFJlYWRvbmx5PGFueT4pID0+IG9iamVjdCksIGlkS2V5OiBzdHJpbmcpOiBUIHtcbiAgICBjb25zdCB1cGRhdGVkRW50aXRpZXMgPSB7fTtcblxuICAgIGxldCBpc1VwZGF0aW5nSWRLZXkgPSBmYWxzZTtcbiAgICBsZXQgaWRUb1VwZGF0ZTogSUQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICBpZFRvVXBkYXRlID0gaWQ7XG4gICAgICBhc3NlcnRFbnRpdHlFeGlzdHMoaWQsIHN0YXRlLmVudGl0aWVzKTtcblxuICAgICAgY29uc3Qgb2xkRW50aXR5ID0gc3RhdGUuZW50aXRpZXNbaWRdO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSBpc0Z1bmN0aW9uKG5ld1N0YXRlT3JGbikgPyBuZXdTdGF0ZU9yRm4ob2xkRW50aXR5KSA6IG5ld1N0YXRlT3JGbjtcblxuICAgICAgaWYgKG5ld1N0YXRlLmhhc093blByb3BlcnR5KGlkS2V5KSAmJiBuZXdTdGF0ZVtpZEtleV0gIT09IG9sZEVudGl0eVtpZEtleV0pIHtcbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFraXRhVXBkYXRlSWRLZXlFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlzVXBkYXRpbmdJZEtleSA9IHRydWU7XG4gICAgICAgIGlkVG9VcGRhdGUgPSBuZXdTdGF0ZVtpZEtleV07XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdFbnRpdHk7XG5cbiAgICAgIGNvbnN0IG1lcmdlZCA9IHtcbiAgICAgICAgLi4ub2xkRW50aXR5LFxuICAgICAgICAuLi5uZXdTdGF0ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob2xkRW50aXR5KSkge1xuICAgICAgICBuZXdFbnRpdHkgPSBtZXJnZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4gY2FzZSB0aGF0IG5ldyBzdGF0ZSBpcyBjbGFzcyBvZiBpdCdzIG93biwgdGhlcmUnc1xuICAgICAgICAgKiBhIHBvc3NpYmlsaXR5IHRoYXQgaXQgd2lsbCBiZSBkaWZmZXJlbnQgdGhhbiB0aGUgb2xkXG4gICAgICAgICAqIGNsYXNzLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgT2xkIHN0YXRlIGlzIGFuIGluc3RhbmNlIG9mIGFuaW1hbCBjbGFzc1xuICAgICAgICAgKiBhbmQgbmV3IHN0YXRlIGlzIGluc3RhbmNlIG9mIHBlcnNvbiBjbGFzcy5cbiAgICAgICAgICogVG8gYXZvaWQgcnVuIG92ZXIgbmV3IHBlcnNvbiBjbGFzcyB3aXRoIHRoZSBvbGQgYW5pbWFsXG4gICAgICAgICAqIGNsYXNzIHdlIGNoZWNrIGlmIHRoZSBuZXcgc3RhdGUgaXMgYSBjbGFzcyBvZiBpdCdzIG93bi5cbiAgICAgICAgICogSWYgc28sIHVzZSBpdC4gT3RoZXJ3aXNlLCB1c2UgdGhlIG9sZCBzdGF0ZSBjbGFzc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QobmV3U3RhdGUpKSB7XG4gICAgICAgICAgbmV3RW50aXR5ID0gbmV3IG9sZEVudGl0eS5jb25zdHJ1Y3RvcihtZXJnZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0VudGl0eSA9IG5ldyAobmV3U3RhdGUgYXMgYW55KS5jb25zdHJ1Y3RvcihtZXJnZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRFbnRpdGllc1tpZFRvVXBkYXRlXSA9IG5ld0VudGl0eTtcbiAgICB9XG5cbiAgICBsZXQgdXBkYXRlZElkcyA9IHN0YXRlLmlkcztcbiAgICBsZXQgc3RhdGVFbnRpdGllcyA9IHN0YXRlLmVudGl0aWVzO1xuICAgIGlmIChpc1VwZGF0aW5nSWRLZXkpIHtcbiAgICAgIGNvbnN0IFtpZF0gPSBpZHM7XG4gICAgICBjb25zdCB7IFtpZF06IGRlbGV0ZWRFbnRpdHksIC4uLnJlc3QgfSA9IHN0YXRlLmVudGl0aWVzO1xuICAgICAgc3RhdGVFbnRpdGllcyA9IHJlc3Q7XG4gICAgICB1cGRhdGVkSWRzID0gc3RhdGUuaWRzLm1hcChjdXJyZW50ID0+IChjdXJyZW50ID09PSBpZCA/IGlkVG9VcGRhdGUgOiBjdXJyZW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLihzdGF0ZSBhcyBhbnkpLFxuICAgICAgZW50aXRpZXM6IHtcbiAgICAgICAgLi4uc3RhdGVFbnRpdGllcyxcbiAgICAgICAgLi4udXBkYXRlZEVudGl0aWVzXG4gICAgICB9LFxuICAgICAgaWRzOiB1cGRhdGVkSWRzXG4gICAgfTtcbiAgfVxuXG4gIF9yZW1vdmU8VCBleHRlbmRzIEVudGl0eVN0YXRlPihzdGF0ZTogVCwgaWRzOiBJRFtdIHwgbnVsbCk6IFQge1xuICAgIGlmICghaWRzKSByZXR1cm4gdGhpcy5fcmVtb3ZlQWxsKHN0YXRlKTtcblxuICAgIGNvbnN0IHJlbW92ZWQgPSBpZHMucmVkdWNlKChhY2MsIGlkKSA9PiB7XG4gICAgICBjb25zdCB7IFtpZF06IGVudGl0eSwgLi4ucmVzdCB9ID0gYWNjO1xuICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgfSwgc3RhdGUuZW50aXRpZXMpO1xuICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgLi4uKHN0YXRlIGFzIGFueSksXG4gICAgICBlbnRpdGllczogcmVtb3ZlZCxcbiAgICAgIGlkczogc3RhdGUuaWRzLmZpbHRlcihjdXJyZW50ID0+IGlkcy5pbmRleE9mKGN1cnJlbnQpID09PSAtMSlcbiAgICB9O1xuXG4gICAgaWYgKHJlc2V0QWN0aXZlKG5ld1N0YXRlKSkge1xuICAgICAgbmV3U3RhdGUuYWN0aXZlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVBbGw8VCBleHRlbmRzIEVudGl0eVN0YXRlPihzdGF0ZTogVCk6IFQge1xuICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgLi4uKHN0YXRlIGFzIGFueSksXG4gICAgICBlbnRpdGllczoge30sXG4gICAgICBpZHM6IFtdLFxuICAgICAgYWN0aXZlOiBudWxsXG4gICAgfTtcblxuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfVxuXG4gIHByaXZhdGUga2V5QnkoZW50aXRpZXM6IGFueVtdLCBlbnRpdHlDbGFzcz86IE5ld2FibGU8YW55PiwgaWQgPSAnaWQnKSB7XG4gICAgY29uc3QgYWNjID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZW50aXRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IGVudGl0aWVzW2ldO1xuICAgICAgYWNjW2VudGl0eVtpZF1dID0gZW50aXR5Q2xhc3MgPyBuZXcgZW50aXR5Q2xhc3MoZW50aXR5KSA6IGVudGl0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBfY3J1ZCA9IG5ldyBDUlVEKCk7XG4iXX0=