import { QueryEntity } from '../api/query-entity';
import { ID, IDS } from '../api/types';
import { Observable } from 'rxjs';
/**
 * Each plugin that wants to add support for entities should extend this interface.
 */
export declare type EntityParam = ID;
export declare type EntityCollectionParams = ID | ID[];
export declare type RebaseActions<P = any> = {
    beforeRemove?: Function;
    beforeAdd?: Function;
    afterAdd?: (plugin: P) => any;
};
export declare abstract class EntityCollectionPlugin<E, P> {
    protected query: QueryEntity<any, E>;
    private entityIds;
    protected entities: Map<ID, P>;
    protected constructor(query: QueryEntity<any, E>, entityIds: EntityCollectionParams);
    /**
     * Get the entity plugin instance.
     */
    protected getEntity(id: ID): P;
    /**
     * Whether the entity plugin exist.
     */
    protected hasEntity(id: ID): boolean;
    /**
     * Remove the entity plugin instance.
     */
    protected removeEntity(id: ID): boolean;
    /**
     * Set the entity plugin instance.
     */
    protected createEntity(id: ID, plugin: P): Map<ID, P>;
    /**
     * If the user passes `entityIds` we take them; otherwise, we take all.
     */
    protected getIds(): ID[];
    /**
     * When you call one of the plugin methods, you can pass id/ids or undefined which means all.
     */
    protected resolvedIds(ids?: any): ID[];
    /**
     * Call this method when you want to activate the plugin on init or when you need to listen to add/remove of entities dynamically.
     *
     * For example in your plugin you may do the following:
     *
     * this.query.select(state => state.ids).pipe(skip(1)).subscribe(ids => this.activate(ids));
     */
    protected rebase(ids: ID[], actions?: RebaseActions<P>): void;
    /**
     * Listen for add/remove entities.
     */
    protected selectIds(): Observable<ID[]>;
    /**
     * Base method for activation, you can override it if you need to.
     */
    protected activate(ids?: ID[]): void;
    /**
     * This method is responsible for plugin instantiation.
     *
     * For example:
     * return new StateHistory(this.query, this.params, id) as P;
     */
    protected abstract instantiatePlugin(id: ID): P;
    /**
     * This method is responsible for cleaning.
     */
    abstract destroy(id?: ID): any;
    /**
     * Loop over each id and invoke the plugin method.
     */
    protected forEachId(ids: IDS, cb: (entity: P) => any): void;
}
