import { HashMap, ID } from './types';
import { Observable, ReplaySubject } from 'rxjs';
import { StoreConfigOptions } from './store-config';
export declare const __stores__: {
    [storeName: string]: Store<any>;
};
export declare const enum Actions {
    NEW_STORE = 0,
    DELETE_STORE = 1,
    NEW_STATE = 2
}
export declare type Action = {
    type: Actions;
    payload: HashMap<any>;
};
export declare const rootDispatcher: ReplaySubject<Action>;
/**
 * Enable production mode to disable objectFreeze
 */
export declare function enableAkitaProdMode(): void;
export declare function isDev(): boolean;
/**
 * The Root Store that every sub store needs to inherit and
 * invoke `super` with the initial state.
 */
export declare class Store<S> {
    private options;
    /** Manage the store with BehaviorSubject */
    private store;
    /** The current state value */
    private storeValue;
    /** Whether we are inside transaction **/
    private inTransaction;
    private _isPristine;
    private readonly _initialState;
    /**
     *
     * Initial the store with the state
     */
    constructor(initialState: any, options?: {
        idKey?: string;
        storeName?: string;
    });
    setLoading(loading?: boolean): void;
    /**
     * Update the store's error state.
     */
    setError<T>(error: T): void;
    /**
     * Select a slice from the store
     *
     * @example
     * this.store.select(state => state.entities)
     *
     */
    _select<R>(project: (store: S) => R): Observable<R>;
    _value(): S;
    readonly config: StoreConfigOptions;
    readonly storeName: any;
    readonly idKey: string;
    readonly isPristine: boolean;
    /**
     * `setState()` is the only way to update a store; It receives a callback function,
     * which gets the current state, and returns a new immutable state,
     * which will be the new value of the store.
     */
    setState(newStateFn: (state: Readonly<S>) => S, _rootDispatcher?: boolean): void;
    /**
     * Resets the store to it's initial state and set the store to a pristine state.
     */
    reset(): void;
    /**
     * This method is a shortcut for `setState()`.
     * It can be useful when you want to pass the whole state object instead of merging a partial state.
     *
     * @example
     * this.store.update(newState)
     */
    update(newState: (state: Readonly<S>) => Partial<S>): any;
    update(newState: Partial<S>): any;
    update(id: ID | ID[] | null, newState: Partial<S>): any;
    /**
     * Sets the store to a pristine state.
     */
    setPristine(): void;
    /**
     * Sets the store to a dirty state, indicating that it is not pristine.
     */
    setDirty(): void;
    destroy: () => void;
    private dispatch;
    private readonly store$;
    /**
     * When the transaction ends dispatch the final value once
     */
    private watchTransaction;
    private isRessetable;
    /**
     * Listen to the transaction stream
     */
    private handleTransaction;
    ngOnDestroy(): void;
}
