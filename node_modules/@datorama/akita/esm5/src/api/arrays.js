/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { isObject } from '../internal/utils';
// https://github.com/georapbox/immutable-arrays
/**
 * Adds one or more elements to the end of an array by returning
 * a new array instead of mutating the original one.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = push(originalArray, 'f', 'g');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd', 'e', 'f', 'g']
 * @template T
 * @param {?} array
 * @param {...?} elementN
 * @return {?}
 */
export function push(array) {
    var elementN = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        elementN[_i - 1] = arguments[_i];
    }
    return tslib_1.__spread(array, elementN);
}
/**
 * Deletes an element from an array by its index in the array.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = remove(originalArray, 2);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'd', 'e']
 * @template T
 * @param {?} array
 * @param {?} index
 * @return {?}
 */
export function remove(array, index) {
    return index >= 0 ? tslib_1.__spread(array.slice(0, index), array.slice(index + 1)) : tslib_1.__spread(array);
}
/**
 * Removes the last element from an array by returning
 * a new array instead of mutating the original one.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = pop(originalArray);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd']
 * @template T
 * @param {?} array
 * @return {?}
 */
export function pop(array) {
    return array.slice(0, -1);
}
/**
 * Adds one or more elements to the beginning of an array.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = unshift(originalArray, 'f', 'g');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['f', 'g', 'a', 'b', 'c', 'd', 'e']
 * @template T
 * @param {?} array
 * @param {...?} elementN
 * @return {?}
 */
export function unshift(array) {
    var elementN = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        elementN[_i - 1] = arguments[_i];
    }
    return tslib_1.__spread(elementN, array);
}
/**
 * Sorts the elements of an array (not in place) and returns a sorted array.
 *
 * \@example
 * const numberArray = [20, 3, 4, 10, -3, 1, 0, 5];
 * const stringArray = ['Blue', 'Humpback', 'Beluga'];
 *
 * const resultArray = sort(numberArray, (a, b) => a - b);
 * // -> numberArray [20, 3, 4, 10, -3, 1, 0, 5]
 * // -> resultArray [-3, 0, 1, 3, 4, 5, 10, 20]
 *
 * const resultArray = sort(numberArray, (a, b) => b - a);
 * // -> numberArray [20, 3, 4, 10, -3, 1, 0, 5]
 * // -> resultArray [20, 10, 5, 4, 3, 1, 0, -3]
 *
 * const resultArray = sort(stringArray);
 * // -> stringArray ['Blue', 'Humpback', 'Beluga']
 * // -> resultArray ['Beluga', 'Blue', 'Humpback']
 *
 * const resultArray = sort(stringArray, (a, b) => a.toLowerCase() < b.toLowerCase());
 * // -> stringArray ['Blue', 'Humpback', 'Beluga']
 * // -> resultArray ['Humpback', 'Blue', 'Beluga']
 * @template T
 * @param {?} array
 * @param {?=} compareFunction
 * @return {?}
 */
export function sort(array, compareFunction) {
    return tslib_1.__spread(array).sort(compareFunction);
}
/**
 * Reverses an array (not in place).
 * The first array element becomes the last, and the last array element becomes the first.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = reverse(originalArray);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['e', 'd', 'c', 'b', 'a']
 * @template T
 * @param {?} array
 * @return {?}
 */
export function reverse(array) {
    return tslib_1.__spread(array).reverse();
}
/**
 * Swap items in the array
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = swap(originalArray, 1, 4);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'e', 'c', 'd', 'b']
 * @template T
 * @param {?} array
 * @param {?} firstIndex
 * @param {?} secondIndex
 * @return {?}
 */
export function swap(array, firstIndex, secondIndex) {
    /** @type {?} */
    var results = array.slice();
    /** @type {?} */
    var firstItem = array[firstIndex];
    results[firstIndex] = array[secondIndex];
    results[secondIndex] = firstItem;
    return results;
}
/**
 * Update item in the array
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = update(originalArray, 1, 'newItem');
 * // -> resultArray ['a', 'newItem', 'c', 'd', 'b']
 *
 * const originalArray = [{title: 1}, {title: 2}];
 * const resultArray = update(originalArray, originalArray[0], {title: 3});
 * // -> resultArray  [{title: 3}, {title: 2}];
 * @template T
 * @param {?} array
 * @param {?} indexOrItem
 * @param {?} updated
 * @return {?}
 */
export function update(array, indexOrItem, updated) {
    return array.map(function (current, idx) {
        if (typeof indexOrItem === 'number' && idx === indexOrItem) {
            return updated;
        }
        if (isObject(indexOrItem) && ((/** @type {?} */ (indexOrItem))) === current) {
            return tslib_1.__assign({}, ((/** @type {?} */ (indexOrItem))), ((/** @type {?} */ (updated))));
        }
        return current;
    });
}
/**
 * Removes existing elements and/or adds new elements to an array.
 *
 * \@example
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray []
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 1);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['b', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 3);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['d', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, originalArray.length);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray []
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, -3);
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 0, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['lorem', 'ipsum', 'a', 'b', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, originalArray.length, 0, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'd', 'e', 'lorem', 'ipsum']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, 0, 2, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['lorem', 'ipsum', 'c', 'd', 'e']
 *
 * const originalArray = ['a', 'b', 'c', 'd', 'e'];
 * const resultArray = splice(originalArray, originalArray.length - 2, 2, 'lorem', 'ipsum');
 * // -> originalArray ['a', 'b', 'c', 'd', 'e']
 * // -> resultArray ['a', 'b', 'c', 'lorem', 'ipsum']
 * @template T
 * @param {?} array
 * @param {?=} start
 * @param {?=} deleteCount
 * @param {...?} elementN
 * @return {?}
 */
export function splice(array, start, deleteCount) {
    if (start === void 0) { start = array.length; }
    if (deleteCount === void 0) { deleteCount = array.length - start; }
    var elementN = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        elementN[_i - 3] = arguments[_i];
    }
    return tslib_1.__spread(array.slice(0, start), elementN, array.slice(start + (deleteCount < 0 ? 0 : deleteCount)));
}
/**
 * @template T
 * @param {?} arr
 * @param {?} item
 * @return {?}
 */
export function toggle(arr, item) {
    return arr.indexOf(item) > -1 ? arr.filter(function (current) { return item !== current; }) : push(arr, item);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXlzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGRhdG9yYW1hL2FraXRhLyIsInNvdXJjZXMiOlsic3JjL2FwaS9hcnJheXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjN0MsTUFBTSxVQUFVLElBQUksQ0FBSSxLQUFVO0lBQUUsa0JBQWdCO1NBQWhCLFVBQWdCLEVBQWhCLHFCQUFnQixFQUFoQixJQUFnQjtRQUFoQixpQ0FBZ0I7O0lBQ2xELHdCQUFXLEtBQUssRUFBSyxRQUFRLEVBQUU7QUFDakMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUFXRCxNQUFNLFVBQVUsTUFBTSxDQUFJLEtBQVUsRUFBRSxLQUFhO0lBQ2pELE9BQU8sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLGtCQUFLLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFLLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsa0JBQUssS0FBSyxDQUFDLENBQUM7QUFDekYsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUFZRCxNQUFNLFVBQVUsR0FBRyxDQUFJLEtBQVU7SUFDL0IsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVCLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FBV0QsTUFBTSxVQUFVLE9BQU8sQ0FBSSxLQUFVO0lBQUUsa0JBQWdCO1NBQWhCLFVBQWdCLEVBQWhCLHFCQUFnQixFQUFoQixJQUFnQjtRQUFoQixpQ0FBZ0I7O0lBQ3JELHdCQUFXLFFBQVEsRUFBSyxLQUFLLEVBQUU7QUFDakMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCRCxNQUFNLFVBQVUsSUFBSSxDQUFJLEtBQVUsRUFBRSxlQUF3QztJQUMxRSxPQUFPLGlCQUFJLEtBQUssRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7QUFDMUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUFZRCxNQUFNLFVBQVUsT0FBTyxDQUFJLEtBQVU7SUFDbkMsT0FBTyxpQkFBSSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUM7QUFDOUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FBV0QsTUFBTSxVQUFVLElBQUksQ0FBSSxLQUFVLEVBQUUsVUFBa0IsRUFBRSxXQUFtQjs7UUFDbkUsT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUU7O1FBQ3ZCLFNBQVMsR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDO0lBQ25DLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDekMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUVqQyxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjRCxNQUFNLFVBQVUsTUFBTSxDQUFJLEtBQVUsRUFBRSxXQUE0QixFQUFFLE9BQVU7SUFDNUUsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUMsT0FBTyxFQUFFLEdBQUc7UUFDNUIsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLElBQUksR0FBRyxLQUFLLFdBQVcsRUFBRTtZQUMxRCxPQUFPLE9BQU8sQ0FBQztTQUNoQjtRQUVELElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsbUJBQUEsV0FBVyxFQUFPLENBQUMsS0FBSyxPQUFPLEVBQUU7WUFDN0QsNEJBQ0ssQ0FBQyxtQkFBQSxXQUFXLEVBQVUsQ0FBQyxFQUN2QixDQUFDLG1CQUFBLE9BQU8sRUFBTyxDQUFDLEVBQ25CO1NBQ0g7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURELE1BQU0sVUFBVSxNQUFNLENBQUksS0FBVSxFQUFFLEtBQW9CLEVBQUUsV0FBa0M7SUFBeEQsc0JBQUEsRUFBQSxRQUFRLEtBQUssQ0FBQyxNQUFNO0lBQUUsNEJBQUEsRUFBQSxjQUFjLEtBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSztJQUFFLGtCQUFnQjtTQUFoQixVQUFnQixFQUFoQixxQkFBZ0IsRUFBaEIsSUFBZ0I7UUFBaEIsaUNBQWdCOztJQUM5Ryx3QkFBVyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBSyxRQUFRLEVBQUssS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUU7QUFDOUcsQ0FBQzs7Ozs7OztBQUVELE1BQU0sVUFBVSxNQUFNLENBQUksR0FBUSxFQUFFLElBQU87SUFDekMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQUEsT0FBTyxJQUFJLE9BQUEsSUFBSSxLQUFLLE9BQU8sRUFBaEIsQ0FBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzVGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4uL2ludGVybmFsL3V0aWxzJztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3JhcGJveC9pbW11dGFibGUtYXJyYXlzXG5cbi8qKlxuICogQWRkcyBvbmUgb3IgbW9yZSBlbGVtZW50cyB0byB0aGUgZW5kIG9mIGFuIGFycmF5IGJ5IHJldHVybmluZ1xuICogYSBuZXcgYXJyYXkgaW5zdGVhZCBvZiBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gcHVzaChvcmlnaW5hbEFycmF5LCAnZicsICdnJyk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZyddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoPFQ+KGFycmF5OiBUW10sIC4uLmVsZW1lbnROOiBUW10pOiBUW10ge1xuICByZXR1cm4gWy4uLmFycmF5LCAuLi5lbGVtZW50Tl07XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBlbGVtZW50IGZyb20gYW4gYXJyYXkgYnkgaXRzIGluZGV4IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHJlbW92ZShvcmlnaW5hbEFycmF5LCAyKTtcbiAqIC8vIC0+IG9yaWdpbmFsQXJyYXkgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydhJywgJ2InLCAnZCcsICdlJ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZTxUPihhcnJheTogVFtdLCBpbmRleDogbnVtYmVyKTogVFtdIHtcbiAgcmV0dXJuIGluZGV4ID49IDAgPyBbLi4uYXJyYXkuc2xpY2UoMCwgaW5kZXgpLCAuLi5hcnJheS5zbGljZShpbmRleCArIDEpXSA6IFsuLi5hcnJheV07XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYnkgcmV0dXJuaW5nXG4gKiBhIG5ldyBhcnJheSBpbnN0ZWFkIG9mIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBvbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSBwb3Aob3JpZ2luYWxBcnJheSk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3A8VD4oYXJyYXk6IFRbXSk6IFRbXSB7XG4gIHJldHVybiBhcnJheS5zbGljZSgwLCAtMSk7XG59XG5cbi8qKlxuICogQWRkcyBvbmUgb3IgbW9yZSBlbGVtZW50cyB0byB0aGUgYmVnaW5uaW5nIG9mIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gdW5zaGlmdChvcmlnaW5hbEFycmF5LCAnZicsICdnJyk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnZicsICdnJywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnNoaWZ0PFQ+KGFycmF5OiBUW10sIC4uLmVsZW1lbnROOiBUW10pOiBUW10ge1xuICByZXR1cm4gWy4uLmVsZW1lbnROLCAuLi5hcnJheV07XG59XG5cbi8qKlxuICogU29ydHMgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IChub3QgaW4gcGxhY2UpIGFuZCByZXR1cm5zIGEgc29ydGVkIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBudW1iZXJBcnJheSA9IFsyMCwgMywgNCwgMTAsIC0zLCAxLCAwLCA1XTtcbiAqIGNvbnN0IHN0cmluZ0FycmF5ID0gWydCbHVlJywgJ0h1bXBiYWNrJywgJ0JlbHVnYSddO1xuICpcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc29ydChudW1iZXJBcnJheSwgKGEsIGIpID0+IGEgLSBiKTtcbiAqIC8vIC0+IG51bWJlckFycmF5IFsyMCwgMywgNCwgMTAsIC0zLCAxLCAwLCA1XVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWy0zLCAwLCAxLCAzLCA0LCA1LCAxMCwgMjBdXG4gKlxuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzb3J0KG51bWJlckFycmF5LCAoYSwgYikgPT4gYiAtIGEpO1xuICogLy8gLT4gbnVtYmVyQXJyYXkgWzIwLCAzLCA0LCAxMCwgLTMsIDEsIDAsIDVdXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbMjAsIDEwLCA1LCA0LCAzLCAxLCAwLCAtM11cbiAqXG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNvcnQoc3RyaW5nQXJyYXkpO1xuICogLy8gLT4gc3RyaW5nQXJyYXkgWydCbHVlJywgJ0h1bXBiYWNrJywgJ0JlbHVnYSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ0JlbHVnYScsICdCbHVlJywgJ0h1bXBiYWNrJ11cbiAqXG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNvcnQoc3RyaW5nQXJyYXksIChhLCBiKSA9PiBhLnRvTG93ZXJDYXNlKCkgPCBiLnRvTG93ZXJDYXNlKCkpO1xuICogLy8gLT4gc3RyaW5nQXJyYXkgWydCbHVlJywgJ0h1bXBiYWNrJywgJ0JlbHVnYSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ0h1bXBiYWNrJywgJ0JsdWUnLCAnQmVsdWdhJ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnQ8VD4oYXJyYXk6IFRbXSwgY29tcGFyZUZ1bmN0aW9uPzogKGE6IFQsIGI6IFQpID0+IG51bWJlcik6IFRbXSB7XG4gIHJldHVybiBbLi4uYXJyYXldLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcbn1cblxuLyoqXG4gKiBSZXZlcnNlcyBhbiBhcnJheSAobm90IGluIHBsYWNlKS5cbiAqIFRoZSBmaXJzdCBhcnJheSBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIGFuZCB0aGUgbGFzdCBhcnJheSBlbGVtZW50IGJlY29tZXMgdGhlIGZpcnN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gcmV2ZXJzZShvcmlnaW5hbEFycmF5KTtcbiAqIC8vIC0+IG9yaWdpbmFsQXJyYXkgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydlJywgJ2QnLCAnYycsICdiJywgJ2EnXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZTxUPihhcnJheTogVFtdKTogVFtdIHtcbiAgcmV0dXJuIFsuLi5hcnJheV0ucmV2ZXJzZSgpO1xufVxuXG4vKipcbiAqIFN3YXAgaXRlbXMgaW4gdGhlIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzd2FwKG9yaWdpbmFsQXJyYXksIDEsIDQpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2EnLCAnZScsICdjJywgJ2QnLCAnYiddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzd2FwPFQ+KGFycmF5OiBUW10sIGZpcnN0SW5kZXg6IG51bWJlciwgc2Vjb25kSW5kZXg6IG51bWJlcik6IFRbXSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBhcnJheS5zbGljZSgpO1xuICBjb25zdCBmaXJzdEl0ZW0gPSBhcnJheVtmaXJzdEluZGV4XTtcbiAgcmVzdWx0c1tmaXJzdEluZGV4XSA9IGFycmF5W3NlY29uZEluZGV4XTtcbiAgcmVzdWx0c1tzZWNvbmRJbmRleF0gPSBmaXJzdEl0ZW07XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogVXBkYXRlIGl0ZW0gaW4gdGhlIGFycmF5XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSB1cGRhdGUob3JpZ2luYWxBcnJheSwgMSwgJ25ld0l0ZW0nKTtcbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYScsICduZXdJdGVtJywgJ2MnLCAnZCcsICdiJ11cbiAqXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gW3t0aXRsZTogMX0sIHt0aXRsZTogMn1dO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSB1cGRhdGUob3JpZ2luYWxBcnJheSwgb3JpZ2luYWxBcnJheVswXSwge3RpdGxlOiAzfSk7XG4gKiAvLyAtPiByZXN1bHRBcnJheSAgW3t0aXRsZTogM30sIHt0aXRsZTogMn1dO1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlPFQ+KGFycmF5OiBUW10sIGluZGV4T3JJdGVtOiBudW1iZXIgfCBvYmplY3QsIHVwZGF0ZWQ6IFQpOiBUW10ge1xuICByZXR1cm4gYXJyYXkubWFwKChjdXJyZW50LCBpZHgpID0+IHtcbiAgICBpZiAodHlwZW9mIGluZGV4T3JJdGVtID09PSAnbnVtYmVyJyAmJiBpZHggPT09IGluZGV4T3JJdGVtKSB7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QoaW5kZXhPckl0ZW0pICYmIChpbmRleE9ySXRlbSBhcyBhbnkpID09PSBjdXJyZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi4oaW5kZXhPckl0ZW0gYXMgb2JqZWN0KSxcbiAgICAgICAgLi4uKHVwZGF0ZWQgYXMgYW55KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBleGlzdGluZyBlbGVtZW50cyBhbmQvb3IgYWRkcyBuZXcgZWxlbWVudHMgdG8gYW4gYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddO1xuICogY29uc3QgcmVzdWx0QXJyYXkgPSBzcGxpY2Uob3JpZ2luYWxBcnJheSwgMCk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFtdXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCAwLCAxKTtcbiAqIC8vIC0+IG9yaWdpbmFsQXJyYXkgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXVxuICogLy8gLT4gcmVzdWx0QXJyYXkgWydiJywgJ2MnLCAnZCcsICdlJ11cbiAqXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc3BsaWNlKG9yaWdpbmFsQXJyYXksIDAsIDMpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2QnLCAnZSddXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCAwLCBvcmlnaW5hbEFycmF5Lmxlbmd0aCk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFtdXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCAwLCAtMyk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc3BsaWNlKG9yaWdpbmFsQXJyYXksIDAsIDAsICdsb3JlbScsICdpcHN1bScpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2xvcmVtJywgJ2lwc3VtJywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKlxuICogY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ107XG4gKiBjb25zdCByZXN1bHRBcnJheSA9IHNwbGljZShvcmlnaW5hbEFycmF5LCBvcmlnaW5hbEFycmF5Lmxlbmd0aCwgMCwgJ2xvcmVtJywgJ2lwc3VtJyk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2xvcmVtJywgJ2lwc3VtJ11cbiAqXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc3BsaWNlKG9yaWdpbmFsQXJyYXksIDAsIDIsICdsb3JlbScsICdpcHN1bScpO1xuICogLy8gLT4gb3JpZ2luYWxBcnJheSBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXG4gKiAvLyAtPiByZXN1bHRBcnJheSBbJ2xvcmVtJywgJ2lwc3VtJywgJ2MnLCAnZCcsICdlJ11cbiAqXG4gKiBjb25zdCBvcmlnaW5hbEFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnXTtcbiAqIGNvbnN0IHJlc3VsdEFycmF5ID0gc3BsaWNlKG9yaWdpbmFsQXJyYXksIG9yaWdpbmFsQXJyYXkubGVuZ3RoIC0gMiwgMiwgJ2xvcmVtJywgJ2lwc3VtJyk7XG4gKiAvLyAtPiBvcmlnaW5hbEFycmF5IFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ11cbiAqIC8vIC0+IHJlc3VsdEFycmF5IFsnYScsICdiJywgJ2MnLCAnbG9yZW0nLCAnaXBzdW0nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaWNlPFQ+KGFycmF5OiBUW10sIHN0YXJ0ID0gYXJyYXkubGVuZ3RoLCBkZWxldGVDb3VudCA9IGFycmF5Lmxlbmd0aCAtIHN0YXJ0LCAuLi5lbGVtZW50TjogVFtdKTogVFtdIHtcbiAgcmV0dXJuIFsuLi5hcnJheS5zbGljZSgwLCBzdGFydCksIC4uLmVsZW1lbnROLCAuLi5hcnJheS5zbGljZShzdGFydCArIChkZWxldGVDb3VudCA8IDAgPyAwIDogZGVsZXRlQ291bnQpKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGU8VD4oYXJyOiBUW10sIGl0ZW06IFQpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pID4gLTEgPyBhcnIuZmlsdGVyKGN1cnJlbnQgPT4gaXRlbSAhPT0gY3VycmVudCkgOiBwdXNoKGFyciwgaXRlbSk7XG59XG4iXX0=